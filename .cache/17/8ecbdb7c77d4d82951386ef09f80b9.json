{"id":"node_modules/@inrupt/solid-client-authn-browser/dist/SessionManager.js","dependencies":[{"name":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\SessionManager.js.map","includedInParent":true,"mtime":1624384349174},{"name":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\SessionManager.ts","includedInParent":true,"mtime":1624384349254},{"name":"G:\\VSC\\mysolidapp\\package.json","includedInParent":true,"mtime":1624384368825},{"name":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\package.json","includedInParent":true,"mtime":1624384349238},{"name":"events","loc":{"line":13,"column":25},"parent":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\SessionManager.js","resolved":"G:\\VSC\\mysolidapp\\node_modules\\events\\events.js"},{"name":"tsyringe","loc":{"line":14,"column":27},"parent":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\SessionManager.js","resolved":"G:\\VSC\\mysolidapp\\node_modules\\tsyringe\\dist\\esm5\\index.js"},{"name":"./Session","loc":{"line":15,"column":26},"parent":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\SessionManager.js","resolved":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\Session.js"},{"name":"./dependencies","loc":{"line":16,"column":31},"parent":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\SessionManager.js","resolved":"G:\\VSC\\mysolidapp\\node_modules\\@inrupt\\solid-client-authn-browser\\dist\\dependencies.js"}],"generated":{"js":"\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SessionManager = void 0;\r\nconst events_1 = require(\"events\");\r\nconst tsyringe_1 = require(\"tsyringe\");\r\nconst Session_1 = require(\"./Session\");\r\nconst dependencies_1 = require(\"./dependencies\");\r\nlet SessionManager = class SessionManager extends events_1.EventEmitter {\r\n    constructor(options = {}) {\r\n        super();\r\n        this.sessionRecords = {};\r\n        this.isInitialized = false;\r\n        this.handledIncomingRedirect = false;\r\n        this.clientAuthn = dependencies_1.getClientAuthenticationWithDependencies({\r\n            secureStorage: options.secureStorage,\r\n            insecureStorage: options.insecureStorage,\r\n        });\r\n    }\r\n    async init() {\r\n        if (!this.isInitialized) {\r\n            await this.handleIncomingRedirect(window.location.href);\r\n            this.isInitialized = true;\r\n        }\r\n    }\r\n    addNewSessionRecord(session) {\r\n        const logoutCallback = () => {\r\n            this.emit(\"sessionLogout\", session);\r\n        };\r\n        session.onLogout(logoutCallback);\r\n        this.sessionRecords[session.info.sessionId] = {\r\n            session,\r\n            logoutCallback,\r\n        };\r\n        return session;\r\n    }\r\n    getSessionFromCurrentSessionInfo(sessionInfo) {\r\n        const sessionRecord = this.sessionRecords[sessionInfo.sessionId];\r\n        if (sessionRecord) {\r\n            sessionRecord.session.info.webId = sessionInfo.webId;\r\n            sessionRecord.session.info.isLoggedIn = sessionInfo.isLoggedIn;\r\n            return sessionRecord.session;\r\n        }\r\n        return this.addNewSessionRecord(new Session_1.Session({\r\n            clientAuthentication: this.clientAuthn,\r\n            sessionInfo,\r\n        }));\r\n    }\r\n    async getSessions() {\r\n        await this.init();\r\n        const sessionInfos = await this.clientAuthn.getAllSessionInfo();\r\n        return sessionInfos.map((sessionInfo) => this.getSessionFromCurrentSessionInfo(sessionInfo));\r\n    }\r\n    async getSession(sessionId) {\r\n        await this.init();\r\n        let session;\r\n        if (sessionId) {\r\n            const retrievedSessionInfo = await this.clientAuthn.getSessionInfo(sessionId);\r\n            if (retrievedSessionInfo) {\r\n                session = this.getSessionFromCurrentSessionInfo(retrievedSessionInfo);\r\n            }\r\n            else {\r\n                session = this.addNewSessionRecord(new Session_1.Session({ clientAuthentication: this.clientAuthn }, sessionId));\r\n            }\r\n        }\r\n        else {\r\n            session = this.addNewSessionRecord(new Session_1.Session({ clientAuthentication: this.clientAuthn }));\r\n        }\r\n        return session;\r\n    }\r\n    async hasSession(sessionId) {\r\n        await this.init();\r\n        return (await this.clientAuthn.getSessionInfo(sessionId)) !== undefined;\r\n    }\r\n    onSessionLogin(callback) {\r\n        this.on(\"sessionLogin\", callback);\r\n    }\r\n    onSessionLogout(callback) {\r\n        this.on(\"sessionLogout\", callback);\r\n    }\r\n    detachSession(sessionId) {\r\n        const sessionRecord = this.sessionRecords[sessionId];\r\n        if (sessionRecord) {\r\n            sessionRecord.session.removeListener(\"onLogout\", sessionRecord.logoutCallback);\r\n            delete this.sessionRecords[sessionId];\r\n        }\r\n    }\r\n    async handleIncomingRedirect(url) {\r\n        const sessionInfo = await this.clientAuthn.handleIncomingRedirect(url);\r\n        if (sessionInfo) {\r\n            const session = this.getSessionFromCurrentSessionInfo(sessionInfo);\r\n            this.emit(\"sessionLogin\", session);\r\n            session.emit(\"login\");\r\n            return session;\r\n        }\r\n        return undefined;\r\n    }\r\n};\r\nSessionManager = __decorate([\r\n    tsyringe_1.injectable(),\r\n    __metadata(\"design:paramtypes\", [Object])\r\n], SessionManager);\r\nexports.SessionManager = SessionManager;\r\n"},"sourceMaps":{"js":{"version":3,"file":"SessionManager.js","sourceRoot":"","sources":["../src/SessionManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright 2021 Inrupt Inc.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal in\r\n * the Software without restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\r\n * Software, and to permit persons to whom the Software is furnished to do so,\r\n * subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nimport { EventEmitter } from \"events\";\r\nimport { ISessionInfo, IStorage } from \"@inrupt/solid-client-authn-core\";\r\nimport { injectable } from \"tsyringe\";\r\nimport { Session } from \"./Session\";\r\nimport ClientAuthentication from \"./ClientAuthentication\";\r\nimport { getClientAuthenticationWithDependencies } from \"./dependencies\";\r\n\r\nexport interface ISessionManagerOptions {\r\n  secureStorage?: IStorage;\r\n  insecureStorage?: IStorage;\r\n}\r\n\r\nexport interface ISessionManager {\r\n  getSession(sessionId?: string): Promise<Session>;\r\n}\r\n\r\n/**\r\n * DEPRECATION NOTE: We don't plan on supporting multi session for client-side\r\n * applications. Please see @inrupt/solid-client-authn-node for server-side\r\n * multi session. This class will be removed in an upcoming major release.\r\n *\r\n * A SessionManager instance can be used to manage all the sessions in an\r\n * application, each session being associated with an individual user.\r\n *\r\n * @deprecated\r\n */\r\n@injectable()\r\nexport class SessionManager extends EventEmitter implements ISessionManager {\r\n  private clientAuthn: ClientAuthentication;\r\n\r\n  private sessionRecords: Record<\r\n    string,\r\n    { session: Session; logoutCallback: () => unknown }\r\n  > = {};\r\n\r\n  private isInitialized = false;\r\n\r\n  private handledIncomingRedirect = false;\r\n\r\n  /**\r\n   * Constructor for the SessionManager object. It is typically used as follows:\r\n   *\r\n   * ```typescript\r\n   * import { SessionManager } from \"@inrupt/solid-client-authn-browser\";\r\n   * import customStorage from \"./myCustomStorage\";\r\n   *\r\n   * const sessionManager = new SessionManager({\r\n   *   secureStorage: customStorage\r\n   * });\r\n   * ```\r\n   * See {@link IStorage} for more information on how to define your own storage mechanism.\r\n   *\r\n   * @param options Options customizing the behaviour of the SessionManager, namely to store data appropriately.\r\n   */\r\n  constructor(options: ISessionManagerOptions = {}) {\r\n    super();\r\n    this.clientAuthn = getClientAuthenticationWithDependencies({\r\n      secureStorage: options.secureStorage,\r\n      insecureStorage: options.insecureStorage,\r\n    });\r\n  }\r\n\r\n  private async init(): Promise<void> {\r\n    if (!this.isInitialized) {\r\n      await this.handleIncomingRedirect(window.location.href);\r\n      this.isInitialized = true;\r\n    }\r\n  }\r\n\r\n  private addNewSessionRecord(session: Session): Session {\r\n    const logoutCallback = (): void => {\r\n      this.emit(\"sessionLogout\", session);\r\n    };\r\n    session.onLogout(logoutCallback);\r\n    this.sessionRecords[session.info.sessionId] = {\r\n      session,\r\n      logoutCallback,\r\n    };\r\n    return session;\r\n  }\r\n\r\n  private getSessionFromCurrentSessionInfo(sessionInfo: ISessionInfo): Session {\r\n    const sessionRecord = this.sessionRecords[sessionInfo.sessionId];\r\n    if (sessionRecord) {\r\n      sessionRecord.session.info.webId = sessionInfo.webId;\r\n      sessionRecord.session.info.isLoggedIn = sessionInfo.isLoggedIn;\r\n      return sessionRecord.session;\r\n    }\r\n    return this.addNewSessionRecord(\r\n      new Session({\r\n        clientAuthentication: this.clientAuthn,\r\n        sessionInfo,\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @returns all the sessions currently managed by the session manager.\r\n   */\r\n  async getSessions(): Promise<Session[]> {\r\n    await this.init();\r\n    const sessionInfos = await this.clientAuthn.getAllSessionInfo();\r\n    return sessionInfos.map((sessionInfo) =>\r\n      this.getSessionFromCurrentSessionInfo(sessionInfo)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Creates a new session and adds it to the session manager.\r\n   * If a session ID is not provided then a random UUID will be\r\n   * assigned as the session ID. If the session of the provided\r\n   * ID already exists then that session will be returned.\r\n   *\r\n   * @param sessionId An optional unique session identifier.\r\n   * @returns A {@link Session} associated with the given ID.\r\n   */\r\n  async getSession(sessionId?: string): Promise<Session> {\r\n    await this.init();\r\n    let session: Session;\r\n    if (sessionId) {\r\n      const retrievedSessionInfo = await this.clientAuthn.getSessionInfo(\r\n        sessionId\r\n      );\r\n      if (retrievedSessionInfo) {\r\n        session = this.getSessionFromCurrentSessionInfo(retrievedSessionInfo);\r\n      } else {\r\n        session = this.addNewSessionRecord(\r\n          new Session({ clientAuthentication: this.clientAuthn }, sessionId)\r\n        );\r\n      }\r\n    } else {\r\n      session = this.addNewSessionRecord(\r\n        new Session({ clientAuthentication: this.clientAuthn })\r\n      );\r\n    }\r\n    return session;\r\n  }\r\n\r\n  /**\r\n   * @param sessionId A unique session identifier.\r\n   * @returns A Promise resolving to true if a session associated with the given ID exists, and false if not.\r\n   */\r\n  async hasSession(sessionId: string): Promise<boolean> {\r\n    await this.init();\r\n    return (await this.clientAuthn.getSessionInfo(sessionId)) !== undefined;\r\n  }\r\n\r\n  /**\r\n   * Registers a callback to be called when a session is logged in.\r\n   *\r\n   * @param callback a function executed when a session logs in, with the session as a parameter.\r\n   */\r\n  onSessionLogin(callback: (session: Session) => unknown): void {\r\n    this.on(\"sessionLogin\", callback);\r\n  }\r\n\r\n  /**\r\n   * Registers a callback to be called when a session is logged out.\r\n   *\r\n   * @param callback a function executed when a session logs out, with the session as a parameter.\r\n   */\r\n  onSessionLogout(callback: (session: Session) => unknown): void {\r\n    this.on(\"sessionLogout\", callback);\r\n  }\r\n\r\n  /**\r\n   * Removes a session from the pool managed by the manager. This is typically useful\r\n   * when a user logs out of the application, so that the number of managed session\r\n   * is not ever-growing. Note that this specific function **does not log out the session**,\r\n   * it only removes references to it, so after this call the session will become unreachable.\r\n   *\r\n   * @param sessionId A unique session identifier.\r\n   * @since 0.2.0\r\n   */\r\n  detachSession(sessionId: string): void {\r\n    const sessionRecord = this.sessionRecords[sessionId];\r\n    if (sessionRecord) {\r\n      sessionRecord.session.removeListener(\r\n        \"onLogout\",\r\n        sessionRecord.logoutCallback\r\n      );\r\n      delete this.sessionRecords[sessionId];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Processes the information sent by the identity provider after\r\n   * the user has logged in, in order to return a logged in {@link Session}.\r\n   *\r\n   * @param url The URL to which the user is being redirected.\r\n   * @returns The {@link Session} that completed login if the process has been successful.\r\n   */\r\n  async handleIncomingRedirect(url: string): Promise<Session | undefined> {\r\n    const sessionInfo = await this.clientAuthn.handleIncomingRedirect(url);\r\n    if (sessionInfo) {\r\n      const session = this.getSessionFromCurrentSessionInfo(sessionInfo);\r\n      this.emit(\"sessionLogin\", session);\r\n      session.emit(\"login\");\r\n      return session;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"]}},"error":null,"hash":"fba07f4ba2aa949b35c1e7b3ae2f9d18","cacheData":{"env":{}}}